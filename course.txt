									 SELECT
извлекаем все данные
SELECT *FROM superuser

выбор столбцов
SELECT name, appearances FROM superheroes

псевдонимы столбцов 
SELECT name AS hero_name, appearances FROM superheroes, SELECT name hero_name, appearances FROM superheroes

выбор уникальных столбцов
SELECT DISTINCT(align) FROM superheroes

ограничение количества извлекаемых строк
SELECT DISTINCT(hair) FROM superheroes LIMIT 10

op. SELECT - извлечение данных
cl.w. FROM - источник данных
cl.w. DISTINCT - выбор уникальных значений в столбцах
cl.w. LIMIT    - ограничение количества извлекаемых строк
cl.w. AS       - создание псевдонима


										 ФИЛЬТРАЦИЯ С ПОМОЩЮ WHERE

выбрать записи где значение столбца gender = 'Female Characters'										 
SELECT * FROM superheroes WHERE gender = 'Female Characters'										 

										ОПЕРАТОРЫ СРАВНЕНИЯ В WHERE
								=			равно
								<>, !=		не равно
								>			больше
								>=			больше или равно
								<			меньше
								<=			меньше или равно
								between		значение находится в указанном диапазоне
								in			значение входит в список
								like		проверка строки на соответствие шаблону
								
выбрать записи с годом между 2000 и 2005
SELECT * FROM superheroes WHERE year BETWEEN 2000 AND 2005	

выбрать записи у которых цвет волос находится в списке
SELECT * FROM superheroes WHERE hair IN ('Strawberry Blond Hair', 'Red Hair', 'Auburn Hair')


										ИСПОЛЬЗОВАНИЕ LIKE В WHERE
									специальные символы в шаблонах LIKE
									% - любое кол-во символов (включая 0)
									_ - ровно один символ
									
									логические операторы в WHERE
									AND - логическое и
									OR - логическое или
									NOT - логическое не
									
выбрать записи содержащие слово Blond									
SELECT * FROM superheroes WHERE hair LIKE '%Blond%'										

AND будет верным в случае выполнения обоих условий, выбрать всех женских отрицательных героев
SELECT * FROM superheroes WHERE gender = 'Female Characters' AND align = 'Bad Characters'

OR будет истинным если выполненно хотябы одно условие, 
выбрать всех героев у которых волосы 'Red Hair', 'Strawsberry Blond Hair' или 'Auburn Hair'
SELECT * FROM superheroes WHERE hair = 'Red Hair' OR 'Strawsberry Blond Hair' OR 'Auburn Hair'

выбрать героев у которых волосы не в сортеже ('Blond Hair', 'Black Hair', 'Brown Hair', 'Red Hair')
SELECT * FROM superheroes WHERE hair NOT IN ('Blond Hair', 'Black Hair', 'Brown Hair', 'Red Hair')


										СОРТИРОВКА В SQL С ПОМОЩЮ ORDER BY
												порядок сортировки
										ASC (ascending) - сортировка по возрастанию (по умолчанию)
										DESC (descending) - сортировка по убыванию
										
выбрать все записи и отсортировать по году
SELECT * FROM superheroes ORDER BY year										

выбрать по полю appearences и сортировать в обратном порядке
SELECT * FROM superheroes ORDER BY appearences DESC

выбрать все записи с отрицательными героями и отсортировать в обратном порядке по полю appearences
SELECT * FROM superheroes WHERE align = 'Bad Characters' ORDER BY appearances DESC

выбрать отрицательных женских героев отсортировать в обратном порядке и вернуть 5 записей
SELECT * FROM superheroes WHERE align = 'Bad Characters' AND gender = 'Female Characters' ORDER BY appearences DESC LIMIT 5

отсортировать по полю year а затем внутри каждого значения year по appearances
SELECT * FROM superheroes ORDER BY year, appearances



										СОЗДАНИЕ ТАБЛИЦ В SQL
										
									DROP TABLE IF EXISTS superheroes;
									CREATE TABLE superheroes(
										id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
										name VARCHAR(100),
										align VARCHAR(30),
										eye VARCHAR(30),
										hair VARCHAR(30),
										gender VARCHAR(30),
										appearances INT,
										year INT,
										universe VARCHAR(100)
									)
									
										ТИПЫ ДАННЫХ В SQL
						CHARACTER(n) (CHAR(n))            - строка фиксированной длинны n
						CHARACTER VARYING(n) (VARCHAR(n)) - строка переменной длинны, максимальная длинна n
						BOOLEAN                           - логический тип данных
						INTEGER (INT)                     - целое число
						NUMERIC(p,s)                      - действительное число (р - количество значащих цифр, s - кол-во цифр после запятой
										                    хранится точно.
						REAL                              - действительное число одинарной точности, формат IEEE 754
						DOUBLE PRECISION                  - действительное число двойной точности, формат IEEE 754
						DATE                              - дата	
						TIMESTAMP                         - дата и время
						
						
												ИЗМЕНЕНИЕ ТАБЛИЦ В SQL
											
											CREATE TABLE - создание таблицы
											DROP TABLE - удаление таблицы
											ALTER TABLE - изменение таблицы
											
												    языки в SQL
									Data Defenition Language (DDL) - язык описания данных
									Data Manipulation Language (DML) - язык манипулирования данными
									Data Control Language (DCL) - язык управления доступом к данным
												
добавить логическую колонку alive в таблицу
ALTER TABLE superheroes ADD COLUMN alive BOOLEAN

добавить колонку даты и времени в таблицу
ALTER TABLE superheroes ADD COLUMN first_appearences TIMESTAMP

удалить колонку year из таблицы
ALTER TABLE superheroes DROP COLUMN year

изменить имя колонки name на hero_name
ALTER TABLE superheroes RENAME COLUMN name TO hero_name

изменить имя таблицы на comic_characters
ALTER TABLE superheroes RENAME TO comic_characters		

										
										
										ВСТАВКА И ИЗМЕНЕНИЕ ДАННЫХ В SQL
										
										INSERT - вставка данных в таблицы
										UPDATE - изменение данных в таблице
										DELETE - удаление данных из таблицы
										
								Один оператор может менять несколько строк данных
								Фильтры в WHERE такие же, как в SELECT (логические и математические)
								Первичный ключ позволяет однозначно идентифицировать строки
										
													вставка
										
создать запись в бд и в указанные поля записать переданные заначения
INSERT INTO superheroes ("name", appearances, universe) VALUES ('Spider-Man', 4043, 'marvel')
								
создать запись с переданными заначениями
INSERT INTO superheroes ("name", align, eye, hair, gender, appearances, "year", universe VALUES ('Spider-Man', 'Good Characters', 'Hazel Eyes', 'Brown Hair', 'Male Characters', 4043, 1962, 'marvel')

													изменение
													
изменение данных в колонках name и universe у строки с id=1
UPDATE superheroes SET name='Batman', universe='dc' WHERE id=1

чтобы изменить несколько записей в фильтре нужно указать параметры фильтрации,
у всех записей с gender='Male Characters' поменять значение gender на man
UPDATE superheroes SET gender='Man' WHERE gender='Male Characters'

													удаление
													
удалить запись с id=2
DELETE FROM superheroes WHERE id=2

также можно удалять несколько записей отфильтровав их по условиям
DELETE FROM superuser WHERE gender='Male Characters'

удалить все записи
DELETE FROM superheroes


									АГРЕГАТНЫЕ ФУНКЦИИ В SQL
									
					обрабатывают несколько строк и вычисляют одно значение.
					используются совместно с групировкой
					
									AVG (average) - среднее значение
									COUNT         - количество значений
									MAX           - максимальное значение
									MIN           - минимальное значение
									SUM           - сумма
					серверы баз данных поддерживают дополнительные функции
					
					агрегатные функции и другие возможности SELECT
					фильтрация (WHERE), сортировка (ORDER BY), ограничение количества строк (LIMIT)
					фильтрация результатов групировки HAVING
									
агрегатные функции это функции которые используются совместно с группировкой,
 получают на входе несколько заначений и вычисляют для них одно значение
 
группируем героев по типу (полож. отриц. и тд) и для каждой группы считаем количество героев в группе
SELECT align, COUNT(*) FROM superheroes GROUP BY align

подсчитаем количество героев каждого типа общую сумму появлений героев этого типа и сгруппируем по типу
SELECT align, COUNT(*), SUM(appearances) FROM superheroes GROUP BY align

вычислим количество героев каждого типа среднее количество появлений в каждой группе, затем общую сумму 
появлений героев в категории разделим на общее количество героев в категории и получим это значение под
псевдонимом average и группируем по типу героев
SELECT align, AVG(appearances), SUM(appearances)/COUNT(*) AS average FROM superheroes GROUP BY align

при делении двух целых чисел в postgress результат тоже целое число, дробная часть отбрасывается

группируем по году и добавляем результаты вычисленный агрегатных функций, минимальное значение колонки appearences и максимальное героя
SELECT year, MIN(appearences), MAX(appearences) FROM superheroes GROUP BY year

ГРУППИРОВКА НЕ ПОДРАЗУМЕВАЕТ СОРТИРОВКУ, МЫ МОЖЕМ ОТСОРТИРОВАТЬ РЕЗУЛЬТАТЫ 
ЗАПРОСА С ИСПОЛЬЗОВАНИЕМ АГРЕГАТНЫХ ФУНКЦИЙ С ПОМОЩЮ ORDER BY
SELECT year, MIN(appearances), MAX(appearances) FROM superheroes GROUP BY year ORDER BY year

также можем отсортировать по результату вычисленному агрегатной функцией MAX() в обратном порядке
SELECT year, MIN(appearances), MAX(appearances) FROM superheroes GROUP BY year ORDER BY MAX(appearances) DESC

можем использовать алиасы
SELECT year, MIN(appearances), MAX(appearances) AS max_ap FROM superuser GROUP BY year ORDER BY max_ap

получим топ 5 самых популярных героев отсортированных по убыванию
SELECT year, MIN(appearances), MAX(appearances) AS max_ap FORM superheroes GROUP BY year ORDER BY max_ap DESC LIMIT 5

также можно использовать агрегатные функции без группировки, тогда в качестве групы выступает вся таблица
тогда COUNT(*) расчитает общее количество строк в таблице и тд
SELECT COUNT(*), MIN(appearances), MAX(appearances), SUM(appearances), AVG(appearances) FROM superheroes


							
							
									ФИЛЬТРАЦИЯ РЕЗУЛЬТАТОВ ГРУПИРОВКИ В SQL: HAVING
									
											фильтрация данных
									WHERE - фильтрация строк в таблице
									HAVING - фильтрация результатов группировки
									
											порядок выполнения SELECT
									FROM - выбор таблицы
									WHERE - фильтрация строк из таблицы
									GROUP BY - группировка
									HAVING - фильтрация результатов группировки
									
подсчитываем модели по цветам волос, только женских персонажей и групируем по цветам волос
SELECT hair, COUNT(*) FROM superheroes WHERE gender='Female Characters' GROUP BY hair	

подсчитываем всех персонажей и фильтруем по полу и по количеству записей в группе больше 10
HAVING указывается для фильтрации групповых результатов и прописывается после ORDER BY (когда уже сформированны все группы)
SELECT hair, COUNT(*) FROM superheroes WHERE gender='Female Characters' ORDER BY hair HAVING COUNT(*) > 10 

подсчитываем повторения уникальных значений поля hair, у женских героев, группируем по цвету волос и фильтруем по значению COUNT() между 50 и 300
SELECT hair, COUNT(*) FROM superheroes WHERE gender='Femali Characters' ORDER BY hair HAVING COUNT(*) BETWEEN 50 and 300
										
									
											ОЛБЬЕДЕНЕНИЕ ДАННЫХ ИЗ НЕСКОЛЬКИХ ТАБЛИЦ В SELECT
											
									в ключевом слове FROM указываем несколько таблиц с JOIN
									после ключевого слова ON указываем условия обьединения
									
									связью между таблицами с помощю ссылок из одной таблицы на другую
									внешний ключ FOREIGN KEY
									
									использование JOIN в SELECT
									комбинация с WHERE, ORDER BY, LIMIT, GROUP BY, HAVING
									типы JOIN: внешнее и внутреннее, левое и правое, перекрестное, полное
									
									В ДАННОМ УРОКЕ МЫ РАССМАТРИВАЕМ ВНУТРЕННЕЕ ОБЬЕДЕНЕНИЕ INER JOIN

выбираем колонки имя продукта и имя категории, из обьеденённых 
таблиц products и product_types связанных через foreign key таблицы продуктов и id таблицы product_types
SELECT products.name, product_tupes.tupe_name FROM products JOIN product_types ON products.type_id = product_types.id											
						
													псевдонимы таблиц
SELECT p.name, t.type_name FROM products AS p JOIN product_types AS t ON p.type_id = t.id		
													
													псевдонимы столбцов и фильтрация
SELECT p.name AS product_name, t.type_name AS product_type, p.price AS product_price FROM products AS p JOIN
products_types AS t ON p.type_id = t.id WHERE t.type_name='Онлайн-курс'	

SELECT p.name AS product_name, t.type_name AS product_type, p.price AS product_price FROM products AS p
JOIN product_types AS t ON p.type_id = t.id WHERE t.type_name = 'Вебинар' AND p.price = 0


											ТИПЫ JOIN В SQL
											
						LEFT OUTER JOIN - левое внешнее обьединение включает строки таблицы слева
даже если для этих строк нет соответствия справа
SELECT products.name, product_types.type_name FROM products LEFT OUTER JOIN product_types ON products.type_id = product_types.id
						
						RIGHT OUTER JOIN - в запрос включаются строки таблицы справа от JOIN даже 
если для них нет соответствия слева
SELECT products.name, product_types.type_name FROM products RIGHT OUTER JOIN product_types ON product.type_id = product_types.id						

						FULL OUTER JOIN - полное внешнее обьединение включает строки обеих таблиц 
у которых нет соответствия в других таблицах	
SELECT products.name, product_types.type_name FROM products FULL OUTER JOIN product_types ON products.type_id = product_types.id					

						CROSS JOIN - перекрёстное обьединение, условие ON не указывается тк
строится на комбинации таблиц каждая строка с каждой
SELECT products.name, product_types.type_name FROM products CROSS JOIN product_types


											СВЯЗИ В БД
											
								ссылка на схему https://drawsql.app/teams/ural-federal-university/diagrams/online-school
											
запрашиваем колонки из таблицы продуктов, quantity из табл. sales и вычисленное значение двух колонок из обеих таблиц
соединяем их по id продукта и ccылку в sales на продукт, фильтруем записи по order_id из таблицы sales											
SELECT p.id, p.name, p.price, s.quantity, p.price * s.quantity AS total FROM products AS p JOIN sales AS s
ON p.id = s.product_id WHERE s.order_id=2	

запрациваем колонки из таблицы продуктов и sales, и вычисляемое значение, обьединяем таблицу продуктов и табл. sales
, затем sales c orders, и фильтруем по id покупателя из таблицы orders	
SELECT p.id, p.name, p.price, s.quantity, p.price * s.quantity AS total FROM product AS p JOIN sales AS s
ON p.id = s.product_id JOIN orders AS o AN o.id = s.order_id WHERE o.customer_id = 1							



												
												КОМАНДЫ POSTGRES
												
							\d superheroes;          - показать данные таблицы